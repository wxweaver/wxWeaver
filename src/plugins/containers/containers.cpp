/*
    wxWeaver - A GUI Designer Editor for wxWidgets.
    Copyright (C) 2005 Jos√© Antonio Hurtado
    Copyright (C) 2005 Juan Antonio Ortega (as wxFormBuilder)
    Copyright (C) 2021 Andrea Zanellato <redtid3@gmail.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/
// Includes collapsiblePane, notebook, listbook, choicebook, auibook
#include "bookutils.h"

#include <plugin.h>
#include <xrcconv.h>

#include <ticpp.h>

#include <wx/splitter.h>

#ifndef __WXGTK__
#include <wx/listctrl.h>
#endif

#if 0
BEGIN_EVENT_TABLE(ComponentEvtHandler, wxEvtHandler)
#ifdef wxUSE_COLLPANE
EVT_COLLAPSIBLEPANE_CHANGED(wxID_ANY, ComponentEvtHandler::OnCollapsiblePaneChanged)
#endif
EVT_NOTEBOOK_PAGE_CHANGED(wxID_ANY, ComponentEvtHandler::OnNotebookPageChanged)
EVT_LISTBOOK_PAGE_CHANGED(wxID_ANY, ComponentEvtHandler::OnListbookPageChanged)
EVT_CHOICEBOOK_PAGE_CHANGED(wxID_ANY, ComponentEvtHandler::OnChoicebookPageChanged)
EVT_AUINOTEBOOK_PAGE_CHANGED(wxID_ANY, ComponentEvtHandler::OnAuiNotebookPageChanged)
EVT_AUINOTEBOOK_PAGE_CLOSE(wxID_ANY, ComponentEvtHandler::OnAuiNotebookPageClosed)
EVT_AUINOTEBOOK_ALLOW_DND(wxID_ANY, ComponentEvtHandler::OnAuiNotebookAllowDND)
EVT_SPLITTER_SASH_POS_CHANGED(wxID_ANY, ComponentEvtHandler::OnSplitterSashChanged)
END_EVENT_TABLE()
#endif

/** Event handler for events generated by controls in this plugin
*/
class ComponentEvtHandler : public wxEvtHandler {
public:
    ComponentEvtHandler(wxWindow* win, IManager* manager)
        : m_window(win)
        , m_manager(manager)
    {
#ifdef wxUSE_COLLPANE
        Bind(wxEVT_COLLAPSIBLEPANE_CHANGED,
             &ComponentEvtHandler::OnCollapsiblePaneChanged, this);
#endif
        Bind(wxEVT_NOTEBOOK_PAGE_CHANGED,
             &ComponentEvtHandler::OnNotebookPageChanged, this);

        Bind(wxEVT_LISTBOOK_PAGE_CHANGED,
             &ComponentEvtHandler::OnListbookPageChanged, this);

        Bind(wxEVT_CHOICEBOOK_PAGE_CHANGED,
             &ComponentEvtHandler::OnChoicebookPageChanged, this);

        Bind(wxEVT_AUINOTEBOOK_PAGE_CHANGED,
             &ComponentEvtHandler::OnAuiNotebookPageChanged, this);

        Bind(wxEVT_AUINOTEBOOK_PAGE_CLOSE,
             &ComponentEvtHandler::OnAuiNotebookPageClosed, this);

        Bind(wxEVT_AUINOTEBOOK_ALLOW_DND,
             &ComponentEvtHandler::OnAuiNotebookAllowDND, this);

        Bind(wxEVT_SPLITTER_SASH_POS_CHANGED,
             &ComponentEvtHandler::OnSplitterSashChanged, this);
    }

protected:
#ifdef wxUSE_COLLPANE
    void OnCollapsiblePaneChanged(wxCollapsiblePaneEvent& event);
#endif
    void OnNotebookPageChanged(wxNotebookEvent& event);
    void OnListbookPageChanged(wxListbookEvent& event);
    void OnChoicebookPageChanged(wxChoicebookEvent& event);
    void OnAuiNotebookPageChanged(wxAuiNotebookEvent& event);
    void OnSplitterSashChanged(wxSplitterEvent& event);

    template <class T>
    void OnBookPageChanged(int selPage, wxEvent* event)
    {
        /*
            TODO: Avoid this by using ids if possible.
            Only handle events from this book: prevents problems with nested books,
            because OnSelected is fired on an object and all of its parents
        */
        if (m_window != event->GetEventObject())
            return;

        if (selPage < 0)
            return;

        size_t count = m_manager->GetChildCount(m_window);
        for (size_t i = 0; i < count; i++) {

            // TODO: use wxobject and iobject variables for all components
            wxObject* wxchild = m_manager->GetChild(m_window, i);
            IObject* iChild = m_manager->GetIObject(wxchild);

            if (iChild) {
                if (selPage == (int)i && !iChild->GetPropertyAsInteger("select"))
                    m_manager->ModifyProperty(wxchild, "select", "1", false);
                else if ((int)i != selPage && iChild->GetPropertyAsInteger("select"))
                    m_manager->ModifyProperty(wxchild, "select", "0", false);
            }
        }
        // Select the corresponding panel in the object tree
        T* book = wxDynamicCast(m_window, T);
        if (book)
            m_manager->SelectObject(book->GetPage(selPage));
    }

    void OnAuiNotebookPageClosed(wxAuiNotebookEvent& event)
    {
        wxMessageBox(
            "wxAuiNotebook pages can normally be closed.\n"
            "However, it is difficult to design a page that has been closed,"
            "so this action has been vetoed.",
            "Page Close Vetoed!", wxICON_INFORMATION, nullptr);

        event.Veto();
    }

    void OnAuiNotebookAllowDND(wxAuiNotebookEvent& event)
    {
        wxMessageBox(
            "wxAuiNotebook pages can be dragged to other wxAuiNotebooks if the"
            "wxEVT_COMMAND_AUINOTEBOOK_ALLOW_DND event is caught and allowed.\n"
            "However, it is difficult to design a page that has been moved,"
            "so this action was not allowed.",
            "Page Move Not Allowed!", wxICON_INFORMATION, nullptr);

        event.Veto();
    }

private:
    wxWindow* m_window;
    IManager* m_manager;
};

class wxCustomSplitterWindow : public wxSplitterWindow {
public:
    wxCustomSplitterWindow(wxWindow* parent, wxWindowID id,
                           const wxPoint& point = wxDefaultPosition,
                           const wxSize& size = wxDefaultSize,
                           long style = wxSP_3D)
        : wxSplitterWindow(parent, id, point, size, style)
        , m_customSashPos(0)
        , m_customMinPaneSize(0)
    {
    }

    // Used to ensure sash position is correct
    void OnIdle(wxIdleEvent&)
    {
        Disconnect(wxEVT_IDLE, wxIdleEventHandler(wxCustomSplitterWindow::OnIdle));

        Freeze();

        // TODO: So many calls for update?
        // So the selection of the sizer at its initial position is cleared,
        // then shown at the correct position
        SetSashPosition(m_initialSashPos);
        Layout();
        Refresh();
        Update();

        Thaw();
    }

private:
    bool OnSashPositionChange(int newSashPosition) override
    {
        m_customSashPos = newSashPosition;
        return wxSplitterWindow::OnSashPositionChange(newSashPosition);
    }

    void OnDoubleClickSash(int, int) override
    {
        if (!m_customMinPaneSize)
            wxMessageBox(
                "Double-clicking a wxSplitterWindow sash with the"
                "minimum pane size set to 0 would normally unsplit it.\n"
                "However, it is difficult to design a pane that has been closed,"
                "so this action has been vetoed.",
                "Unsplit Vetoed!", wxICON_INFORMATION, nullptr);
    }

public: // TODO
    int m_customSashPos;
    int m_customMinPaneSize;
    int m_initialSashPos;
};

// TODO: Since wxGTK 2.8, wxNotebook has been sending page changed events
// in its destructor; this causes strange behavior
#if defined(__WXGTK__)
class wxCustomNotebook : public wxNotebook {
public:
    wxCustomNotebook(wxWindow* parent, wxWindowID id,
                     const wxPoint& point = wxDefaultPosition,
                     const wxSize& size = wxDefaultSize,
                     long style = 0)
        : wxNotebook(parent, id, point, size, style)
    {
    }

    ~wxCustomNotebook() override
    {
        while (this != GetEventHandler()) {
            // Remove and delete extra event handlers
            PopEventHandler(true);
        }
    }
};
#else
typedef wxNotebook wxCustomNotebook;
#endif

class PanelComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxPanel* panel = new wxPanel(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("style")
                | obj->GetPropertyAsInteger("window_style"));

        return panel;
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxPanel",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxPanel");
        filter.AddWindowProperties();
        return filter.GetXfbObject();
    }
};

#ifdef wxUSE_COLLPANE
class CollapsiblePaneComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxCollapsiblePane* collapsiblePane = new wxCollapsiblePane(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsString("label"),
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("style")
                | obj->GetPropertyAsInteger("window_style"));

        collapsiblePane->Collapse(obj->GetPropertyAsInteger("collapsed"));
        collapsiblePane->PushEventHandler(
            new ComponentEvtHandler(collapsiblePane, GetManager()));

        return collapsiblePane;
    }

    void Cleanup(wxObject* obj) override
    {
        wxCollapsiblePane* collapsiblePane = wxDynamicCast(obj, wxCollapsiblePane);
        if (collapsiblePane)
            collapsiblePane->PopEventHandler(true);
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxCollapsiblePane",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        xrc.AddProperty("label", "label", XRC_TYPE_TEXT);
        xrc.AddProperty("collapsed", "collapsed", XRC_TYPE_BOOL);
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxCollapsiblePane");
        filter.AddWindowProperties();
        filter.AddProperty("label", "label", XRC_TYPE_TEXT);
        filter.AddProperty("collapsed", "collapsed", XRC_TYPE_BOOL);
        return filter.GetXfbObject();
    }
};

void ComponentEvtHandler::OnCollapsiblePaneChanged(wxCollapsiblePaneEvent& event)
{
    wxCollapsiblePane* collapsiblePane = wxDynamicCast(m_window, wxCollapsiblePane);
    if (!collapsiblePane)
        return;

    wxString s = (event.GetCollapsed()) ? "1" : "0";
    m_manager->ModifyProperty(collapsiblePane, "collapsed", s);
    collapsiblePane->SetFocus();

    event.Skip();
}
#endif // wxUSE_COLLPANE

class SplitterWindowComponent : public ComponentBase {
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxCustomSplitterWindow* splitter = new wxCustomSplitterWindow(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            (obj->GetPropertyAsInteger("style")
             | obj->GetPropertyAsInteger("window_style"))
                & ~wxSP_PERMIT_UNSPLIT);

        if (!obj->IsNull("sashgravity")) {
            float gravity = obj->GetPropertyAsFloat("sashgravity");
            gravity = (gravity < 0.0 ? 0.0 : gravity);
            gravity = (gravity > 1.0 ? 1.0 : gravity);
            splitter->SetSashGravity(gravity);
        }
        if (!obj->IsNull("min_pane_size")) {
            int minPaneSize = obj->GetPropertyAsInteger("min_pane_size");
            splitter->m_customMinPaneSize = minPaneSize;
            minPaneSize = (minPaneSize < 1 ? 1 : minPaneSize);
            splitter->SetMinimumPaneSize(minPaneSize);
        }

        // Always have a child so it is drawn consistently
        splitter->Initialize(new wxPanel(splitter));

        // Used to ensure sash position is correct
        splitter->m_initialSashPos = obj->GetPropertyAsInteger("sashpos");

        splitter->Connect(wxEVT_IDLE, wxIdleEventHandler(wxCustomSplitterWindow::OnIdle));

        return splitter;
    }

    void Cleanup(wxObject* obj) override
    {
        // The derived class doesn't implement wxWidgets RTTI so cast to its base class
        wxSplitterWindow* splitter = wxDynamicCast(obj, wxSplitterWindow);
        if (!splitter)
            return;

        // Because of possible error conditions the handler might not have been pushed
        ComponentEvtHandler* compHandler
            = dynamic_cast<ComponentEvtHandler*>(splitter->GetEventHandler());

        if (compHandler)
            splitter->PopEventHandler(true);
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxSplitterWindow",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        xrc.AddProperty("sashpos", "sashpos", XRC_TYPE_INTEGER);
        xrc.AddProperty("sashgravity", "gravity", XRC_TYPE_FLOAT);
        xrc.AddProperty("min_pane_size", "minsize", XRC_TYPE_INTEGER);

        if (obj->GetPropertyAsString("splitmode") == "wxSPLIT_VERTICAL")
            xrc.AddPropertyValue("orientation", "vertical");
        else
            xrc.AddPropertyValue("orientation", "horizontal");

        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxSplitterWindow");
        filter.AddWindowProperties();
        filter.AddProperty("sashpos", "sashpos", XRC_TYPE_INTEGER);
        filter.AddProperty("gravity", "sashgravity", XRC_TYPE_FLOAT);
        filter.AddProperty("minsize", "min_pane_size", XRC_TYPE_INTEGER);
        try {
            ticpp::Element* splitmode = xrcObj->FirstChildElement("orientation");
            std::string value = splitmode->GetText();
            if (value == "vertical")
                filter.AddPropertyValue("splitmode", "wxSPLIT_VERTICAL");
            else
                filter.AddPropertyValue("splitmode", "wxSPLIT_HORIZONTAL");
        } catch (ticpp::Exception&) {
        }
        return filter.GetXfbObject();
    }

    void OnCreated(wxObject* wxobject, wxWindow* /*wxparent*/) override
    {
        wxCustomSplitterWindow* splitter = wxDynamicCast(wxobject, wxCustomSplitterWindow);
        if (!splitter) {
            // TODO: Too much debugging?
            wxLogError("This should be a wxSplitterWindow");
            return;
        }

        // Remove default panel
        wxWindow* firstChild = splitter->GetWindow1();

        size_t childCount = GetManager()->GetChildCount(wxobject);
        switch (childCount) {
        case 1: {
            // The child should be a splitteritem
            wxObject* splitterItem = GetManager()->GetChild(wxobject, 0);

            // This one should be the actual wxWindow
            wxWindow* subwindow = wxDynamicCast(GetManager()->GetChild(splitterItem, 0), wxWindow);
            if (!subwindow) {
                wxLogError("A SplitterItem is abstract and must have a child!");
                return;
            }

            if (firstChild) {
                splitter->ReplaceWindow(firstChild, subwindow);
                firstChild->Destroy();
            } else {
                splitter->Initialize(subwindow);
            }
            splitter->PushEventHandler(new ComponentEvtHandler(splitter, GetManager()));
            break;
        }
        case 2: {
            // The child should be a splitteritem
            wxObject* splitterItem0 = GetManager()->GetChild(wxobject, 0);
            wxObject* splitterItem1 = GetManager()->GetChild(wxobject, 1);

            // This one should be the actual wxWindow
            wxWindow* subwindow0 = wxDynamicCast(GetManager()->GetChild(splitterItem0, 0), wxWindow);
            wxWindow* subwindow1 = wxDynamicCast(GetManager()->GetChild(splitterItem1, 0), wxWindow);

            if (!subwindow0 || !subwindow1) {
                wxLogError("A SplitterItem is abstract and must have a child!");
                return;
            }

            // Get the split mode and sash position
            IObject* obj = GetManager()->GetIObject(wxobject);
            if (!obj)
                return;

            int sashPos = obj->GetPropertyAsInteger("sashpos");
            int splitmode = obj->GetPropertyAsInteger("splitmode");

            if (firstChild) {
                splitter->ReplaceWindow(firstChild, subwindow0);
                firstChild->Destroy();
            }

            if (splitmode == wxSPLIT_VERTICAL) {
                splitter->SplitVertically(subwindow0, subwindow1, sashPos);
            } else {
                splitter->SplitHorizontally(subwindow0, subwindow1, sashPos);
            }

            splitter->PushEventHandler(new ComponentEvtHandler(splitter, GetManager()));
            break;
        }
        default:
            return;
        }
    }
};

void ComponentEvtHandler::OnSplitterSashChanged(wxSplitterEvent&)
{
    wxCustomSplitterWindow* splitter = wxDynamicCast(m_window, wxCustomSplitterWindow);
    if (!splitter)
        return;

    if (splitter->m_customSashPos)
        m_manager->ModifyProperty(
            splitter, "sashpos",
            wxString::Format("%i", splitter->GetSashPosition()));
}

class SplitterItemComponent : public ComponentBase {
    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        // A __dummyitem__ will be ignored...
        ObjectToXrcFilter xrc(obj, "__dummyitem__", "");
        return xrc.GetXrcObject();
    }
};

class ScrolledWindowComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxScrolledWindow* sw = new wxScrolledWindow(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("style")
                | obj->GetPropertyAsInteger("window_style"));

        sw->SetScrollRate(
            obj->GetPropertyAsInteger("scroll_rate_x"),
            obj->GetPropertyAsInteger("scroll_rate_y"));

        return sw;
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxScrolledWindow",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        xrc.AddPropertyValue(
            "scrollrate",
            wxString::Format(
                "%d,%d",
                obj->GetPropertyAsInteger("scroll_rate_x"),
                obj->GetPropertyAsInteger("scroll_rate_y")));

        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxScrolledWindow");
        filter.AddWindowProperties();

        ticpp::Element* scrollrate = xrcObj->FirstChildElement("scrollrate", false);
        if (scrollrate) {
            wxString value(wxString(scrollrate->GetText().c_str(), wxConvUTF8));
            filter.AddPropertyValue("scroll_rate_x", value.BeforeFirst(','));
            filter.AddPropertyValue("scroll_rate_y", value.AfterFirst(','));
        }
        return filter.GetXfbObject();
    }
};

class NotebookComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxNotebook* noteBook = new wxCustomNotebook(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("style")
                | obj->GetPropertyAsInteger("window_style"));

        BookUtils::AddImageList(obj, noteBook);

        noteBook->PushEventHandler(new ComponentEvtHandler(noteBook, GetManager()));

        return noteBook;
    }

    void Cleanup(wxObject* obj) override
    {
        wxNotebook* noteBook = wxDynamicCast(obj, wxNotebook);
        if (noteBook)
            noteBook->PopEventHandler(true);
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxNotebook",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxNotebook");
        filter.AddWindowProperties();
        return filter.GetXfbObject();
    }
};

void ComponentEvtHandler::OnNotebookPageChanged(wxNotebookEvent& event)
{
    OnBookPageChanged<wxNotebook>(event.GetSelection(), &event);
    event.Skip();
}

class NotebookPageComponent : public ComponentBase {
public:
    void OnCreated(wxObject* wxobject, wxWindow* wxparent) override
    {
        BookUtils::OnCreated<wxNotebook>(
            wxobject, wxparent, GetManager(), "NotebookPageComponent");
    }

    void OnSelected(wxObject* wxobject) override
    {
        BookUtils::OnSelected<wxNotebook>(wxobject, GetManager());
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "notebookpage");
        xrc.AddProperty("label", "label", XRC_TYPE_TEXT);
        xrc.AddProperty("select", "selected", XRC_TYPE_BOOL);
        if (!obj->IsNull("bitmap")) {
            xrc.AddProperty("bitmap", "bitmap", XRC_TYPE_BITMAP);
        }
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "notebookpage");
        filter.AddWindowProperties();
        filter.AddProperty("label", "label", XRC_TYPE_TEXT);
        filter.AddProperty("selected", "select", XRC_TYPE_BOOL);
        filter.AddProperty("bitmap", "bitmap", XRC_TYPE_BITMAP);
        return filter.GetXfbObject();
    }
};

class ListbookComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxListbook* listBook = new wxListbook(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("style")
                | obj->GetPropertyAsInteger("window_style"));

        BookUtils::AddImageList(obj, listBook);
        listBook->PushEventHandler(new ComponentEvtHandler(listBook, GetManager()));
        return listBook;
    }

    void Cleanup(wxObject* obj) override
    {
        wxListbook* listBook = wxDynamicCast(obj, wxListbook);
        if (listBook)
            listBook->PopEventHandler(true);
    }

// TODO: What??
// Small icon style not supported by GTK
#ifndef __WXGTK__
    void OnCreated(wxObject* wxobject, wxWindow* wxparent) override
    {
        wxListbook* book = wxDynamicCast(wxparent, wxListbook);
        if (book) {
            // Small icon style if bitmapsize is not set
            IObject* obj = GetManager()->GetIObject(wxobject);
            if (obj->GetPropertyAsString("bitmapsize").empty()) {
                wxListView* tmpListView = book->GetListView();
                long flags = tmpListView->GetWindowStyleFlag();
                flags = (flags & ~wxLC_ICON) | wxLC_SMALL_ICON;
                tmpListView->SetWindowStyleFlag(flags);
            }
        }
    }
#endif

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxListbook",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxListbook");
        filter.AddWindowProperties();
        return filter.GetXfbObject();
    }
};

void ComponentEvtHandler::OnListbookPageChanged(wxListbookEvent& event)
{
    OnBookPageChanged<wxListbook>(event.GetSelection(), &event);
    event.Skip();
}

class ListbookPageComponent : public ComponentBase {
public:
    void OnCreated(wxObject* wxobject, wxWindow* wxparent) override
    {
        BookUtils::OnCreated<wxListbook>(
            wxobject, wxparent, GetManager(), "ListbookPageComponent");
    }

    void OnSelected(wxObject* wxobject) override
    {
        BookUtils::OnSelected<wxListbook>(wxobject, GetManager());
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "listbookpage");
        xrc.AddProperty("label", "label", XRC_TYPE_TEXT);
        xrc.AddProperty("select", "selected", XRC_TYPE_BOOL);
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "listbookpage");
        filter.AddWindowProperties();
        filter.AddProperty("selected", "select", XRC_TYPE_BOOL);
        filter.AddProperty("label", "label", XRC_TYPE_TEXT);
        return filter.GetXfbObject();
    }
};

class ChoicebookComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxChoicebook* choiceBook = new wxChoicebook(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("style")
                | obj->GetPropertyAsInteger("window_style"));

        choiceBook->PushEventHandler(new ComponentEvtHandler(choiceBook, GetManager()));
        return choiceBook;
    }

    void Cleanup(wxObject* obj) override
    {
        wxChoicebook* choiceBook = wxDynamicCast(obj, wxChoicebook);
        if (choiceBook)
            choiceBook->PopEventHandler(true);
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxChoicebook",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxChoicebook");
        filter.AddWindowProperties();
        return filter.GetXfbObject();
    }
};

void ComponentEvtHandler::OnChoicebookPageChanged(wxChoicebookEvent& event)
{
    OnBookPageChanged<wxChoicebook>(event.GetSelection(), &event);
    event.Skip();
}

class ChoicebookPageComponent : public ComponentBase {
public:
    void OnCreated(wxObject* wxobject, wxWindow* wxparent) override
    {
        BookUtils::OnCreated<wxChoicebook>(
            wxobject, wxparent, GetManager(), "ChoicebookPageComponent");
    }

    void OnSelected(wxObject* wxobject) override
    {
        BookUtils::OnSelected<wxChoicebook>(wxobject, GetManager());
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "choicebookpage");
        xrc.AddProperty("label", "label", XRC_TYPE_TEXT);
        xrc.AddProperty("select", "selected", XRC_TYPE_BOOL);
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "choicebookpage");
        filter.AddWindowProperties();
        filter.AddProperty("selected", "select", XRC_TYPE_BOOL);
        filter.AddProperty("label", "label", XRC_TYPE_TEXT);
        return filter.GetXfbObject();
    }
};

class AuiNotebookComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxAuiNotebook* auiNotebook = new wxAuiNotebook(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("style")
                | obj->GetPropertyAsInteger("window_style"));

        auiNotebook->SetTabCtrlHeight(obj->GetPropertyAsInteger("tab_ctrl_height"));
        auiNotebook->SetUniformBitmapSize(obj->GetPropertyAsSize("uniform_bitmap_size"));
        auiNotebook->PushEventHandler(new ComponentEvtHandler(auiNotebook, GetManager()));
        return auiNotebook;
    }

    void Cleanup(wxObject* obj) override
    {
        wxAuiNotebook* auiNotebook = wxDynamicCast(obj, wxAuiNotebook);
        if (auiNotebook)
            auiNotebook->PopEventHandler(true);
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxAuiNotebook",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxAuiNotebook");
        filter.AddWindowProperties();
        return filter.GetXfbObject();
    }
};

void ComponentEvtHandler::OnAuiNotebookPageChanged(wxAuiNotebookEvent& event)
{
    OnBookPageChanged<wxAuiNotebook>(event.GetSelection(), &event);
    event.Skip();
}

class AuiNotebookPageComponent : public ComponentBase {
public:
    void OnCreated(wxObject* wxobject, wxWindow* wxparent) override
    {
        // Easy read-only property access
        IObject* obj = GetManager()->GetIObject(wxobject);

        wxAuiNotebook* auiNotebook = wxDynamicCast(wxparent, wxAuiNotebook);
        // TODO: copied code, need refactor
#if 0
        // This wouldn't compile in MinGW, strange
        wxWindow* page = wxDynamicCast(manager->GetChild(wxobject, 0), wxWindow);

        // Do this instead
#else
        wxObject* child = GetManager()->GetChild(wxobject, 0);
        wxWindow* page = nullptr;
        if (child->IsKindOf(CLASSINFO(wxWindow)))
            page = (wxWindow*)child;
#endif
        // Error checking
        if (!(obj && auiNotebook && page)) {
            wxLogError(
                "AuiNotebookPageComponent is missing its wxWeaver object(%i),"
                "its parent(%i), or its child(%i)",
                obj, auiNotebook, page);
            return;
        }
        // Prevent event handling by wxWeaver - these aren't user generated events
        SuppressEventHandlers suppress(auiNotebook);

        // Save selection
        int selection = auiNotebook->GetSelection();
        const wxBitmap& bitmap = obj->IsNull("bitmap")
            ? wxNullBitmap
            : obj->GetPropertyAsBitmap("bitmap");

        auiNotebook->AddPage(page, obj->GetPropertyAsString("label"), false, bitmap);

        if (obj->GetPropertyAsString("select") == "0" && selection >= 0)
            auiNotebook->SetSelection(selection);
        else
            auiNotebook->SetSelection(auiNotebook->GetPageCount() - 1);
    }

    void OnSelected(wxObject* wxobject) override
    {
        BookUtils::OnSelected<wxAuiNotebook>(wxobject, GetManager());
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "notebookpage");
        xrc.AddProperty("label", "label", XRC_TYPE_TEXT);
        xrc.AddProperty("selected", "selected", XRC_TYPE_BOOL);
        xrc.AddProperty("bitmap", "bitmap", XRC_TYPE_BITMAP);
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "notebookpage");
        filter.AddWindowProperties();
        filter.AddProperty("selected", "selected", XRC_TYPE_BOOL);
        filter.AddProperty("label", "label", XRC_TYPE_TEXT);
        filter.AddProperty("bitmap", "bitmap", XRC_TYPE_BITMAP);
        return filter.GetXfbObject();
    }
};

class SimplebookComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        return new wxSimplebook(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("window_style"));
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxSimplebook",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxSimplebook");
        filter.AddWindowProperties();
        return filter.GetXfbObject();
    }
};

class SimplebookPageComponent : public ComponentBase {
public:
    void OnCreated(wxObject* wxobject, wxWindow* wxparent) override
    {
        BookUtils::OnCreated<wxSimplebook>(
            wxobject, wxparent, GetManager(), "SimplebookPageComponent");
    }

    void OnSelected(wxObject* wxobject) override
    {
        BookUtils::OnSelected<wxSimplebook>(wxobject, GetManager());
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "simplebookpage");
        xrc.AddProperty("label", "label", XRC_TYPE_TEXT);
        xrc.AddProperty("select", "selected", XRC_TYPE_BOOL);
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "simplebookpage");
        filter.AddWindowProperties();
        filter.AddProperty("label", "label", XRC_TYPE_TEXT);
        filter.AddProperty("selected", "select", XRC_TYPE_BOOL);
        return filter.GetXfbObject();
    }
};

BEGIN_LIBRARY()
WINDOW_COMPONENT("wxPanel", PanelComponent)

#ifdef wxUSE_COLLPANE
WINDOW_COMPONENT("wxCollapsiblePane", CollapsiblePaneComponent)
#endif

WINDOW_COMPONENT("wxSplitterWindow", SplitterWindowComponent)
ABSTRACT_COMPONENT("splitteritem", SplitterItemComponent)

WINDOW_COMPONENT("wxScrolledWindow", ScrolledWindowComponent)

WINDOW_COMPONENT("wxNotebook", NotebookComponent)
ABSTRACT_COMPONENT("notebookpage", NotebookPageComponent)

WINDOW_COMPONENT("wxListbook", ListbookComponent)
ABSTRACT_COMPONENT("listbookpage", ListbookPageComponent)

WINDOW_COMPONENT("wxChoicebook", ChoicebookComponent)
ABSTRACT_COMPONENT("choicebookpage", ChoicebookPageComponent)

WINDOW_COMPONENT("wxAuiNotebook", AuiNotebookComponent)
ABSTRACT_COMPONENT("auinotebookpage", AuiNotebookPageComponent)

WINDOW_COMPONENT("wxSimplebook", SimplebookComponent)
ABSTRACT_COMPONENT("simplebookpage", SimplebookPageComponent)

#ifdef wxUSE_COLLPANE
// wxCollapsiblePane
MACRO(wxCP_DEFAULT_STYLE)
MACRO(wxCP_NO_TLW_RESIZE)
#endif

// wxSplitterWindow
MACRO(wxSP_3D)
MACRO(wxSP_3DSASH)
MACRO(wxSP_3DBORDER)
MACRO(wxSP_BORDER)
MACRO(wxSP_NOBORDER)
MACRO(wxSP_NOSASH)
MACRO(wxSP_THIN_SASH)
MACRO(wxSP_NO_XP_THEME)
MACRO(wxSP_PERMIT_UNSPLIT)
MACRO(wxSP_LIVE_UPDATE)

MACRO(wxSPLIT_VERTICAL)
MACRO(wxSPLIT_HORIZONTAL)

// wxScrolledWindow
MACRO(wxHSCROLL);
MACRO(wxVSCROLL);

// wxNotebook
MACRO(wxNB_TOP)
MACRO(wxNB_LEFT)
MACRO(wxNB_RIGHT)
MACRO(wxNB_BOTTOM)
MACRO(wxNB_FIXEDWIDTH)
MACRO(wxNB_MULTILINE)
MACRO(wxNB_NOPAGETHEME)

// wxListbook
MACRO(wxLB_TOP)
MACRO(wxLB_LEFT)
MACRO(wxLB_RIGHT)
MACRO(wxLB_BOTTOM)
MACRO(wxLB_DEFAULT)

// wxChoicebook
MACRO(wxCHB_TOP)
MACRO(wxCHB_LEFT)
MACRO(wxCHB_RIGHT)
MACRO(wxCHB_BOTTOM)
MACRO(wxCHB_DEFAULT)

// wxAuiNotebook
MACRO(wxAUI_NB_DEFAULT_STYLE)
MACRO(wxAUI_NB_TAB_SPLIT)
MACRO(wxAUI_NB_TAB_MOVE)
MACRO(wxAUI_NB_TAB_EXTERNAL_MOVE)
MACRO(wxAUI_NB_TAB_FIXED_WIDTH)
MACRO(wxAUI_NB_SCROLL_BUTTONS)
MACRO(wxAUI_NB_WINDOWLIST_BUTTON)
MACRO(wxAUI_NB_CLOSE_BUTTON)
MACRO(wxAUI_NB_CLOSE_ON_ACTIVE_TAB)
MACRO(wxAUI_NB_CLOSE_ON_ALL_TABS)
MACRO(wxAUI_NB_MIDDLE_CLICK_CLOSE)
MACRO(wxAUI_NB_TOP)
MACRO(wxAUI_NB_BOTTOM)
END_LIBRARY()
