/*
    wxWeaver - A GUI Designer Editor for wxWidgets.
    Copyright (C) 2005 Jos√© Antonio Hurtado
    Copyright (C) 2005 Juan Antonio Ortega (as wxFormBuilder)
    Copyright (C) 2021 Andrea Zanellato <redtid3@gmail.com>

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/
#include "bookctrls.h"

#include <plugin.h>
#include <xrcconv.h>

#include <ticpp.h>

#include <wx/splitter.h>

#ifdef wxUSE_COLLPANE
#include <wx/collpane.h>
#endif

#ifndef __WXGTK__
#include <wx/listctrl.h>
#endif

#if 0
BEGIN_EVENT_TABLE(ContainersEvtHandler, wxEvtHandler)
#ifdef wxUSE_COLLPANE
EVT_COLLAPSIBLEPANE_CHANGED(wxID_ANY, ContainersEvtHandler::OnCollapsiblePaneChanged)
#endif
EVT_SPLITTER_SASH_POS_CHANGED(wxID_ANY, ContainersEvtHandler::OnSplitterSashChanged)
END_EVENT_TABLE()
#endif

/** Event handler for events generated by controls in this plugin
*/
class ContainersEvtHandler : public wxEvtHandler {
public:
    ContainersEvtHandler(wxWindow* win, IManager* manager)
        : m_window(win)
        , m_manager(manager)
    {
#ifdef wxUSE_COLLPANE
        Bind(wxEVT_COLLAPSIBLEPANE_CHANGED,
             &ContainersEvtHandler::OnCollapsiblePaneChanged, this);
#endif
        Bind(wxEVT_SPLITTER_SASH_POS_CHANGED,
             &ContainersEvtHandler::OnSplitterSashChanged, this);
    }

protected:
#ifdef wxUSE_COLLPANE
    void OnCollapsiblePaneChanged(wxCollapsiblePaneEvent& event);
#endif
    void OnSplitterSashChanged(wxSplitterEvent& event);

private:
    wxWindow* m_window;
    IManager* m_manager;
};

class wxCustomSplitterWindow : public wxSplitterWindow {
public:
    wxCustomSplitterWindow(wxWindow* parent, wxWindowID id,
                           const wxPoint& point = wxDefaultPosition,
                           const wxSize& size = wxDefaultSize,
                           long style = wxSP_3D)
        : wxSplitterWindow(parent, id, point, size, style)
        , m_customSashPos(0)
        , m_customMinPaneSize(0)
    {
    }

    // Used to ensure sash position is correct
    void OnIdle(wxIdleEvent&)
    {
        Disconnect(wxEVT_IDLE, wxIdleEventHandler(wxCustomSplitterWindow::OnIdle));

        Freeze();

        // TODO: So many calls for update?
        // So the selection of the sizer at its initial position is cleared,
        // then shown at the correct position
        SetSashPosition(m_initialSashPos);
        Layout();
        Refresh();
        Update();

        Thaw();
    }

private:
    bool OnSashPositionChange(int newSashPosition) override
    {
        m_customSashPos = newSashPosition;
        return wxSplitterWindow::OnSashPositionChange(newSashPosition);
    }

    void OnDoubleClickSash(int, int) override
    {
        if (!m_customMinPaneSize)
            wxMessageBox(
                "Double-clicking a wxSplitterWindow sash with the"
                "minimum pane size set to 0 would normally unsplit it.\n"
                "However, it is difficult to design a pane that has been closed,"
                "so this action has been vetoed.",
                "Unsplit Vetoed!", wxICON_INFORMATION, nullptr);
    }

public: // TODO
    int m_customSashPos;
    int m_customMinPaneSize;
    int m_initialSashPos;
};

class PanelComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxPanel* panel = new wxPanel(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("style")
                | obj->GetPropertyAsInteger("window_style"));

        return panel;
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxPanel",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxPanel");
        filter.AddWindowProperties();
        return filter.GetXfbObject();
    }
};

#ifdef wxUSE_COLLPANE
class CollapsiblePaneComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxCollapsiblePane* collapsiblePane = new wxCollapsiblePane(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsString("label"),
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("style")
                | obj->GetPropertyAsInteger("window_style"));

        collapsiblePane->Collapse(obj->GetPropertyAsInteger("collapsed"));
        collapsiblePane->PushEventHandler(
            new ContainersEvtHandler(collapsiblePane, GetManager()));

        return collapsiblePane;
    }

    void Cleanup(wxObject* obj) override
    {
        wxCollapsiblePane* collapsiblePane = wxDynamicCast(obj, wxCollapsiblePane);
        if (collapsiblePane)
            collapsiblePane->PopEventHandler(true);
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxCollapsiblePane",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        xrc.AddProperty("label", "label", XRC_TYPE_TEXT);
        xrc.AddProperty("collapsed", "collapsed", XRC_TYPE_BOOL);
        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxCollapsiblePane");
        filter.AddWindowProperties();
        filter.AddProperty("label", "label", XRC_TYPE_TEXT);
        filter.AddProperty("collapsed", "collapsed", XRC_TYPE_BOOL);
        return filter.GetXfbObject();
    }
};

void ContainersEvtHandler::OnCollapsiblePaneChanged(wxCollapsiblePaneEvent& event)
{
    wxCollapsiblePane* collapsiblePane = wxDynamicCast(m_window, wxCollapsiblePane);
    if (!collapsiblePane)
        return;

    wxString s = (event.GetCollapsed()) ? "1" : "0";
    m_manager->ModifyProperty(collapsiblePane, "collapsed", s);
    collapsiblePane->SetFocus();

    event.Skip();
}
#endif // wxUSE_COLLPANE

class SplitterWindowComponent : public ComponentBase {
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxCustomSplitterWindow* splitter = new wxCustomSplitterWindow(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            (obj->GetPropertyAsInteger("style")
             | obj->GetPropertyAsInteger("window_style"))
                & ~wxSP_PERMIT_UNSPLIT);

        if (!obj->IsNull("sashgravity")) {
            float gravity = obj->GetPropertyAsFloat("sashgravity");
            gravity = (gravity < 0.0 ? 0.0 : gravity);
            gravity = (gravity > 1.0 ? 1.0 : gravity);
            splitter->SetSashGravity(gravity);
        }
        if (!obj->IsNull("min_pane_size")) {
            int minPaneSize = obj->GetPropertyAsInteger("min_pane_size");
            splitter->m_customMinPaneSize = minPaneSize;
            minPaneSize = (minPaneSize < 1 ? 1 : minPaneSize);
            splitter->SetMinimumPaneSize(minPaneSize);
        }

        // Always have a child so it is drawn consistently
        splitter->Initialize(new wxPanel(splitter));

        // Used to ensure sash position is correct
        splitter->m_initialSashPos = obj->GetPropertyAsInteger("sashpos");

        splitter->Connect(wxEVT_IDLE, wxIdleEventHandler(wxCustomSplitterWindow::OnIdle));

        return splitter;
    }

    void Cleanup(wxObject* obj) override
    {
        // The derived class doesn't implement wxWidgets RTTI so cast to its base class
        wxSplitterWindow* splitter = wxDynamicCast(obj, wxSplitterWindow);
        if (!splitter)
            return;

        // Because of possible error conditions the handler might not have been pushed
        ContainersEvtHandler* compHandler
            = dynamic_cast<ContainersEvtHandler*>(splitter->GetEventHandler());

        if (compHandler)
            splitter->PopEventHandler(true);
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxSplitterWindow",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        xrc.AddProperty("sashpos", "sashpos", XRC_TYPE_INTEGER);
        xrc.AddProperty("sashgravity", "gravity", XRC_TYPE_FLOAT);
        xrc.AddProperty("min_pane_size", "minsize", XRC_TYPE_INTEGER);

        if (obj->GetPropertyAsString("splitmode") == "wxSPLIT_VERTICAL")
            xrc.AddPropertyValue("orientation", "vertical");
        else
            xrc.AddPropertyValue("orientation", "horizontal");

        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxSplitterWindow");
        filter.AddWindowProperties();
        filter.AddProperty("sashpos", "sashpos", XRC_TYPE_INTEGER);
        filter.AddProperty("gravity", "sashgravity", XRC_TYPE_FLOAT);
        filter.AddProperty("minsize", "min_pane_size", XRC_TYPE_INTEGER);
        try {
            ticpp::Element* splitmode = xrcObj->FirstChildElement("orientation");
            std::string value = splitmode->GetText();
            if (value == "vertical")
                filter.AddPropertyValue("splitmode", "wxSPLIT_VERTICAL");
            else
                filter.AddPropertyValue("splitmode", "wxSPLIT_HORIZONTAL");
        } catch (ticpp::Exception&) {
        }
        return filter.GetXfbObject();
    }

    void OnCreated(wxObject* wxobject, wxWindow* /*wxparent*/) override
    {
        wxCustomSplitterWindow* splitter = wxDynamicCast(wxobject, wxCustomSplitterWindow);
        if (!splitter) {
            // TODO: Too much debugging?
            wxLogError("This should be a wxSplitterWindow");
            return;
        }

        // Remove default panel
        wxWindow* firstChild = splitter->GetWindow1();

        size_t childCount = GetManager()->GetChildCount(wxobject);
        switch (childCount) {
        case 1: {
            // The child should be a splitteritem
            wxObject* splitterItem = GetManager()->GetChild(wxobject, 0);

            // This one should be the actual wxWindow
            wxWindow* subwindow = wxDynamicCast(GetManager()->GetChild(splitterItem, 0), wxWindow);
            if (!subwindow) {
                wxLogError("A SplitterItem is abstract and must have a child!");
                return;
            }

            if (firstChild) {
                splitter->ReplaceWindow(firstChild, subwindow);
                firstChild->Destroy();
            } else {
                splitter->Initialize(subwindow);
            }
            splitter->PushEventHandler(new ContainersEvtHandler(splitter, GetManager()));
            break;
        }
        case 2: {
            // The child should be a splitteritem
            wxObject* splitterItem0 = GetManager()->GetChild(wxobject, 0);
            wxObject* splitterItem1 = GetManager()->GetChild(wxobject, 1);

            // This one should be the actual wxWindow
            wxWindow* subwindow0 = wxDynamicCast(GetManager()->GetChild(splitterItem0, 0), wxWindow);
            wxWindow* subwindow1 = wxDynamicCast(GetManager()->GetChild(splitterItem1, 0), wxWindow);

            if (!subwindow0 || !subwindow1) {
                wxLogError("A SplitterItem is abstract and must have a child!");
                return;
            }

            // Get the split mode and sash position
            IObject* obj = GetManager()->GetIObject(wxobject);
            if (!obj)
                return;

            int sashPos = obj->GetPropertyAsInteger("sashpos");
            int splitmode = obj->GetPropertyAsInteger("splitmode");

            if (firstChild) {
                splitter->ReplaceWindow(firstChild, subwindow0);
                firstChild->Destroy();
            }

            if (splitmode == wxSPLIT_VERTICAL) {
                splitter->SplitVertically(subwindow0, subwindow1, sashPos);
            } else {
                splitter->SplitHorizontally(subwindow0, subwindow1, sashPos);
            }

            splitter->PushEventHandler(new ContainersEvtHandler(splitter, GetManager()));
            break;
        }
        default:
            return;
        }
    }
};

void ContainersEvtHandler::OnSplitterSashChanged(wxSplitterEvent&)
{
    wxCustomSplitterWindow* splitter = wxDynamicCast(m_window, wxCustomSplitterWindow);
    if (!splitter)
        return;

    if (splitter->m_customSashPos)
        m_manager->ModifyProperty(
            splitter, "sashpos",
            wxString::Format("%i", splitter->GetSashPosition()));
}

class SplitterItemComponent : public ComponentBase {
    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        // A __dummyitem__ will be ignored...
        ObjectToXrcFilter xrc(obj, "__dummyitem__", "");
        return xrc.GetXrcObject();
    }
};

class ScrolledWindowComponent : public ComponentBase {
public:
    wxObject* Create(IObject* obj, wxObject* parent) override
    {
        wxScrolledWindow* sw = new wxScrolledWindow(
            (wxWindow*)parent, wxID_ANY,
            obj->GetPropertyAsPoint("pos"),
            obj->GetPropertyAsSize("size"),
            obj->GetPropertyAsInteger("style")
                | obj->GetPropertyAsInteger("window_style"));

        sw->SetScrollRate(
            obj->GetPropertyAsInteger("scroll_rate_x"),
            obj->GetPropertyAsInteger("scroll_rate_y"));

        return sw;
    }

    ticpp::Element* ExportToXrc(IObject* obj) override
    {
        ObjectToXrcFilter xrc(obj, "wxScrolledWindow",
                              obj->GetPropertyAsString("name"));
        xrc.AddWindowProperties();
        xrc.AddPropertyValue(
            "scrollrate",
            wxString::Format(
                "%d,%d",
                obj->GetPropertyAsInteger("scroll_rate_x"),
                obj->GetPropertyAsInteger("scroll_rate_y")));

        return xrc.GetXrcObject();
    }

    ticpp::Element* ImportFromXrc(ticpp::Element* xrcObj) override
    {
        XrcToXfbFilter filter(xrcObj, "wxScrolledWindow");
        filter.AddWindowProperties();

        ticpp::Element* scrollrate = xrcObj->FirstChildElement("scrollrate", false);
        if (scrollrate) {
            wxString value(wxString(scrollrate->GetText().c_str(), wxConvUTF8));
            filter.AddPropertyValue("scroll_rate_x", value.BeforeFirst(','));
            filter.AddPropertyValue("scroll_rate_y", value.AfterFirst(','));
        }
        return filter.GetXfbObject();
    }
};

BEGIN_LIBRARY()

WINDOW_COMPONENT("wxPanel", PanelComponent)

#ifdef wxUSE_COLLPANE
WINDOW_COMPONENT("wxCollapsiblePane", CollapsiblePaneComponent)
#endif

WINDOW_COMPONENT("wxSplitterWindow", SplitterWindowComponent)
ABSTRACT_COMPONENT("splitteritem", SplitterItemComponent)

WINDOW_COMPONENT("wxScrolledWindow", ScrolledWindowComponent)

WINDOW_COMPONENT("wxNotebook", NotebookComponent)
ABSTRACT_COMPONENT("notebookpage", NotebookPageComponent)

WINDOW_COMPONENT("wxListbook", ListbookComponent)
ABSTRACT_COMPONENT("listbookpage", ListbookPageComponent)

WINDOW_COMPONENT("wxChoicebook", ChoicebookComponent)
ABSTRACT_COMPONENT("choicebookpage", ChoicebookPageComponent)

WINDOW_COMPONENT("wxAuiNotebook", AuiNotebookComponent)
ABSTRACT_COMPONENT("auinotebookpage", AuiNotebookPageComponent)

WINDOW_COMPONENT("wxSimplebook", SimplebookComponent)
ABSTRACT_COMPONENT("simplebookpage", SimplebookPageComponent)

#ifdef wxUSE_COLLPANE
// wxCollapsiblePane
MACRO(wxCP_DEFAULT_STYLE)
MACRO(wxCP_NO_TLW_RESIZE)
#endif

// wxSplitterWindow
MACRO(wxSP_3D)
MACRO(wxSP_3DSASH)
MACRO(wxSP_3DBORDER)
MACRO(wxSP_BORDER)
MACRO(wxSP_NOBORDER)
MACRO(wxSP_NOSASH)
MACRO(wxSP_THIN_SASH)
MACRO(wxSP_NO_XP_THEME)
MACRO(wxSP_PERMIT_UNSPLIT)
MACRO(wxSP_LIVE_UPDATE)

MACRO(wxSPLIT_VERTICAL)
MACRO(wxSPLIT_HORIZONTAL)

// wxScrolledWindow
MACRO(wxHSCROLL);
MACRO(wxVSCROLL);

// wxNotebook
MACRO(wxNB_TOP)
MACRO(wxNB_LEFT)
MACRO(wxNB_RIGHT)
MACRO(wxNB_BOTTOM)
MACRO(wxNB_FIXEDWIDTH)
MACRO(wxNB_MULTILINE)
MACRO(wxNB_NOPAGETHEME)

// wxListbook
MACRO(wxLB_TOP)
MACRO(wxLB_LEFT)
MACRO(wxLB_RIGHT)
MACRO(wxLB_BOTTOM)
MACRO(wxLB_DEFAULT)

// wxChoicebook
MACRO(wxCHB_TOP)
MACRO(wxCHB_LEFT)
MACRO(wxCHB_RIGHT)
MACRO(wxCHB_BOTTOM)
MACRO(wxCHB_DEFAULT)

// wxAuiNotebook
MACRO(wxAUI_NB_DEFAULT_STYLE)
MACRO(wxAUI_NB_TAB_SPLIT)
MACRO(wxAUI_NB_TAB_MOVE)
MACRO(wxAUI_NB_TAB_EXTERNAL_MOVE)
MACRO(wxAUI_NB_TAB_FIXED_WIDTH)
MACRO(wxAUI_NB_SCROLL_BUTTONS)
MACRO(wxAUI_NB_WINDOWLIST_BUTTON)
MACRO(wxAUI_NB_CLOSE_BUTTON)
MACRO(wxAUI_NB_CLOSE_ON_ACTIVE_TAB)
MACRO(wxAUI_NB_CLOSE_ON_ALL_TABS)
MACRO(wxAUI_NB_MIDDLE_CLICK_CLOSE)
MACRO(wxAUI_NB_TOP)
MACRO(wxAUI_NB_BOTTOM)

END_LIBRARY()
